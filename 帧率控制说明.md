# 帧率控制机制说明

## 概述

双相机控制工具现在实现了**固定30fps录制**功能，确保即使相机掉帧，输出的视频也始终保持30fps的稳定帧率。

## 工作原理

### 1. 目标帧率设置

- **目标帧率**: 30 fps（可配置）
- **帧间隔**: 1/30 = 0.0333 秒（每帧间隔）

### 2. 帧率控制机制

#### 正常情况（无掉帧）

```
时间轴: 0.000s  0.033s  0.067s  0.100s  0.133s  ...
帧号:   0       1       2       3       4       ...
```

每0.033秒写入一帧，保持稳定的30fps。

#### 掉帧情况处理

当相机无法及时提供新帧时，系统会：

1. **检测掉帧**：
   - 计算应该写入的帧数：`expected_frames = elapsed_time × 30`
   - 计算实际写入的帧数：`actual_frames = frame_count`
   - 如果 `expected_frames > actual_frames`，说明掉帧了

2. **处理掉帧**：
   - 写入当前帧（如果可用）
   - 如果掉帧数 > 1，重复写入上一帧
   - 确保视频始终保持30fps

**示例**：
```
时间轴: 0.000s  0.033s  0.067s  0.100s  0.133s  0.167s
应该:   帧0     帧1     帧2     帧3     帧4     帧5
实际:   帧0     帧1     (掉帧)   (掉帧)  帧2     帧3
处理:   帧0     帧1     帧1*    帧1*    帧2     帧3
```

`帧1*` 表示重复的帧，用于填补掉帧的空缺。

### 3. 掉帧检测

系统会检测以下情况：

- **相机读取失败**：`cap.read()` 返回 `False`
- **帧延迟**：相机提供帧的速度慢于30fps
- **系统性能问题**：处理速度跟不上

### 4. 统计信息

录制过程中会实时显示：

- **实际帧率**：当前实际写入的帧率
- **掉帧数**：检测到的掉帧数量
- **重复帧数**：为保持30fps而重复写入的帧数

## 显示信息

录制时，视频画面会显示：

```
REC 15.2s | 29.8fps
Drop: 3 | Dup: 3
```

- **REC 15.2s**: 录制时长
- **29.8fps**: 实际帧率（应该接近30fps）
- **Drop: 3**: 掉帧数
- **Dup: 3**: 重复帧数

## 输出文件信息

### 时间戳文件

`timestamps_*.json` 文件包含每帧的详细信息：

```json
{
  "total_frames": 900,
  "target_fps": 30.0,
  "actual_fps": 29.95,
  "dropped_frames": 5,
  "duplicated_frames": 5,
  "frame_timestamps": [
    {
      "frame_num": 0,
      "elapsed": 0.000,
      "is_duplicate": false
    },
    {
      "frame_num": 1,
      "elapsed": 0.033,
      "is_duplicate": false
    },
    {
      "frame_num": 2,
      "elapsed": 0.067,
      "is_duplicate": true  // 这是重复帧
    }
  ]
}
```

## 优势

### 1. 稳定的帧率

- ✅ 输出视频始终是30fps
- ✅ 不会因为掉帧导致视频播放速度异常
- ✅ 适合后续的时间分析

### 2. 时间同步

- ✅ 每帧都有准确的时间戳
- ✅ 两个相机的视频时间完全同步
- ✅ 可以精确对齐帧序列

### 3. 掉帧处理

- ✅ 自动检测和处理掉帧
- ✅ 使用上一帧填补空缺（保持画面连续性）
- ✅ 记录详细的统计信息

## 注意事项

### 1. 掉帧原因

如果频繁掉帧，可能的原因：

- **相机性能不足**：相机无法提供30fps
- **USB带宽不足**：USB接口速度不够
- **系统性能问题**：CPU/内存不足
- **存储速度慢**：写入速度跟不上

### 2. 优化建议

如果掉帧严重：

1. **降低分辨率**：
   ```bash
   python dual_camera_control.py --width 640 --height 480
   ```

2. **降低帧率**（如果允许）：
   ```bash
   python dual_camera_control.py --fps 15
   ```

3. **使用更快的存储**：SSD 比 HDD 快

4. **关闭其他程序**：释放系统资源

### 3. 重复帧的影响

- 重复帧会保持画面的连续性
- 对于静态场景，影响很小
- 对于快速运动，可能会有轻微卡顿
- 时间戳仍然准确，可以用于分析

## 技术细节

### 帧率控制算法

```python
# 计算应该写入的帧数
elapsed = current_time - start_time
expected_frame_num = int(elapsed * target_fps)
frames_behind = expected_frame_num - frame_count

# 如果落后，写入帧
if frames_behind > 0:
    # 写入当前帧
    write_current_frame()
    
    # 如果落后多帧，重复写入上一帧
    if frames_behind > 1:
        for i in range(frames_behind - 1):
            write_duplicate_frame()
```

### 时间戳更新

重复帧的时间戳会正确更新：

```python
# 重复帧的时间戳 = 当前时间 - (落后帧数 - 当前重复帧索引) × 帧间隔
dup_elapsed = elapsed - (frames_behind - 1 - i) * frame_interval
```

这确保了即使使用重复帧，时间戳也是准确的。

## 验证方法

### 1. 检查视频帧率

使用 ffprobe 检查视频：

```bash
ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate video.avi
```

应该显示：`30/1` 或 `30.00 fps`

### 2. 检查帧数

```bash
ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames video.avi
```

帧数应该 = 录制时长（秒）× 30

### 3. 检查时间戳文件

查看 `timestamps_*.json` 文件：
- `actual_fps` 应该接近 30.0
- `dropped_frames` 和 `duplicated_frames` 应该相等（如果掉帧被完全处理）

## 总结

帧率控制机制确保了：

1. ✅ **稳定的30fps输出**：无论相机是否掉帧
2. ✅ **准确的时间戳**：每帧都有精确的时间信息
3. ✅ **详细的统计**：记录掉帧和处理情况
4. ✅ **时间同步**：两个相机视频完全同步

这使得录制的视频非常适合后续的时间分析和处理任务。

