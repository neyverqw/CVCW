# 双相机标定工具使用说明

## 功能说明

这个工具用于对两个相机进行棋盘格标定，实时显示焦距，确保两个相机焦距一致，适合后续的立体视觉应用。

## 安装依赖

```bash
pip install opencv-python numpy
```

## 使用方法

### 基本用法

```bash
python camera_calibration.py
```

默认配置：
- 相机1: ID=0, 名称=Camera1
- 相机2: ID=1, 名称=Camera2
- 棋盘格: 9x6 内角点
- 方格大小: 25mm

### 自定义参数

```bash
python camera_calibration.py \
    --camera1 0 \
    --camera2 1 \
    --name1 "BottomView" \
    --name2 "SideView" \
    --chessboard "9x6" \
    --square-size 25.0
```

### 参数说明

- `--camera1`: 第一个相机的ID（默认: 0）
- `--camera2`: 第二个相机的ID（默认: 1）
- `--name1`: 第一个相机的名称（默认: Camera1）
- `--name2`: 第二个相机的名称（默认: Camera2）
- `--chessboard`: 棋盘格内角点数量，格式为 "宽x高"（默认: 9x6）
- `--square-size`: 棋盘格方格的实际大小，单位：毫米（默认: 25.0）

## 操作步骤

### 1. 准备棋盘格

- 打印一个棋盘格图案（或使用平板显示）
- 确保棋盘格平整，没有弯曲
- 测量并记录每个方格的实际大小（毫米）

### 2. 标定第一个相机

1. 运行脚本后，会打开第一个相机的窗口
2. 将棋盘格放在相机前，调整位置和角度
3. 当检测到棋盘格时，画面会显示绿色提示
4. 按 `s` 键保存当前帧（建议保存15-20张不同角度和位置的图像）
5. 收集足够图像后，按 `c` 键执行标定
6. 标定完成后，会显示焦距信息
7. 按 `q` 键退出第一个相机的标定

### 3. 标定第二个相机

1. 脚本会自动切换到第二个相机
2. 重复步骤2的操作
3. 确保使用相同的棋盘格和方格大小

### 4. 查看结果

- 标定结果会保存在 `calibration_results/` 目录
- 每个相机会生成：
  - `{相机名称}_calibration.json`: JSON格式的标定数据
  - `{相机名称}_calibration.npz`: NumPy格式的标定数据（方便后续使用）

### 5. 焦距比较

- 标定完成后，脚本会自动比较两个相机的焦距
- 如果焦距差异小于1%，适合立体视觉
- 如果差异较大，会给出调整建议

## 键盘操作

在标定窗口中：

- **`s`**: 保存当前帧用于标定（需要先检测到棋盘格）
- **`c`**: 执行标定（需要至少10张图像）
- **`r`**: 重置标定数据（清空已收集的图像）
- **`q`**: 退出当前相机的标定

## 标定质量建议

### 图像收集建议

1. **数量**: 至少收集15-20张图像，建议20-30张
2. **角度**: 从不同角度拍摄（正面、侧面、倾斜等）
3. **位置**: 棋盘格在画面中的不同位置
4. **距离**: 不同距离（近、中、远）
5. **光照**: 确保光照充足且均匀

### 标定质量指标

- **重投影误差**: 应该小于0.5像素（理想情况下）
- **焦距一致性**: 两个相机焦距差异应小于5%

## 使用标定结果

### 在Python中加载标定数据

```python
import numpy as np
import json

# 方法1: 加载NumPy格式（推荐）
data = np.load('calibration_results/Camera1_calibration.npz')
camera_matrix = data['camera_matrix']
dist_coeffs = data['dist_coeffs']
focal_length = data['focal_length']

# 方法2: 加载JSON格式
with open('calibration_results/Camera1_calibration.json', 'r') as f:
    calib_data = json.load(f)
    camera_matrix = np.array(calib_data['camera_matrix'])
    dist_coeffs = np.array(calib_data['distortion_coefficients'])
    focal_length = calib_data['focal_length']
```

### 用于立体视觉

如果两个相机焦距一致，可以直接使用标定结果进行立体标定：

```python
import cv2

# 加载两个相机的标定数据
# ... (加载camera_matrix1, dist_coeffs1, camera_matrix2, dist_coeffs2)

# 执行立体标定
ret, K1, D1, K2, D2, R, T, E, F = cv2.stereoCalibrate(
    object_points, image_points1, image_points2,
    camera_matrix1, dist_coeffs1,
    camera_matrix2, dist_coeffs2,
    image_size
)
```

## 常见问题

### Q: 检测不到棋盘格？

A: 
- 确保棋盘格平整，没有弯曲
- 确保光照充足
- 调整相机角度和距离
- 检查棋盘格大小参数是否正确

### Q: 标定误差很大？

A:
- 增加标定图像数量（建议20-30张）
- 确保图像质量高，棋盘格清晰
- 从更多不同角度拍摄
- 检查方格大小参数是否正确

### Q: 两个相机焦距差异很大？

A:
- 如果相机支持，调整焦距设置
- 尝试调整相机到棋盘格的距离
- 如果无法调整，可以使用立体标定方法（OpenCV可以处理焦距差异）

### Q: 如何知道相机ID？

A:
- 在Linux/Mac: 通常是 `/dev/video0`, `/dev/video1` 等，ID为0, 1, 2...
- 在Windows: 通常是0, 1, 2...
- 可以尝试不同的ID值，直到找到正确的相机

## 注意事项

1. **棋盘格质量**: 确保棋盘格打印清晰，方格大小准确
2. **环境光照**: 确保光照充足且均匀，避免强烈阴影
3. **相机稳定性**: 标定过程中保持相机稳定
4. **标定顺序**: 建议先标定一个相机，再标定另一个
5. **保存结果**: 标定完成后及时保存结果，避免丢失

## 示例输出

```
============================================================
双相机棋盘格标定工具
============================================================

配置:
  相机1: ID=0, 名称=Camera1
  相机2: ID=1, 名称=Camera2
  棋盘格: 9x6 内角点
  方格大小: 25.0mm

============================================================
步骤 1/2: 标定第一个相机
============================================================
✓ 已保存第 1 张标定图像
✓ 已保存第 2 张标定图像
...
✓ Camera1 标定完成!
  焦距: 856.32 像素
  重投影误差: 0.2341 像素

============================================================
步骤 2/2: 标定第二个相机
============================================================
...
✓ Camera2 标定完成!
  焦距: 857.18 像素
  重投影误差: 0.2156 像素

============================================================
焦距比较结果:
  Camera1: 856.32 像素
  Camera2: 857.18 像素
  差异: 0.86 像素 (0.10%)
  ✓ 焦距非常接近，适合立体视觉
============================================================
```

